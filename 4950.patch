From 1db64045bc5316a782f866b2a1069bb3b64c4082 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 13:49:55 +0800
Subject: [PATCH 1/9] [LLVM 21] `setTargetTriple` now takes a `Triple`

---
 driver/codegenerator.cpp    |  4 ++++
 gen/dcompute/targetCUDA.cpp |  4 ++++
 gen/dcompute/targetOCL.cpp  | 11 ++++++++---
 3 files changed, 16 insertions(+), 3 deletions(-)

diff --git a/driver/codegenerator.cpp b/driver/codegenerator.cpp
index c70284225c1..8982bea851a 100644
--- a/driver/codegenerator.cpp
+++ b/driver/codegenerator.cpp
@@ -216,7 +216,11 @@ void CodeGenerator::prepareLLModule(Module *m) {
   // name, as it should not collide with a symbol name used somewhere in the
   // module.
   ir_ = new IRState(m->srcfile.toChars(), context_);
+#if LDC_LLVM_VER >= 2100
+  ir_->module.setTargetTriple(*global.params.targetTriple);
+#else
   ir_->module.setTargetTriple(global.params.targetTriple->str());
+#endif
   ir_->module.setDataLayout(*gDataLayout);
 
   // TODO: Make ldc::DIBuilder per-Module to be able to emit several CUs for
diff --git a/gen/dcompute/targetCUDA.cpp b/gen/dcompute/targetCUDA.cpp
index c093941efe8..ffd2711accf 100644
--- a/gen/dcompute/targetCUDA.cpp
+++ b/gen/dcompute/targetCUDA.cpp
@@ -43,7 +43,11 @@ class TargetCUDA : public DComputeTarget {
         llvm::Reloc::Static, llvm::CodeModel::Medium, codeGenOptLevel(), false);
 
     _ir = new IRState("dcomputeTargetCUDA", ctx);
+#if LDC_LLVM_VER >= 2100
+    _ir->module.setTargetTriple(llvm::Triple(tripleString));
+#else
     _ir->module.setTargetTriple(tripleString);
+#endif
     _ir->module.setDataLayout(targetMachine->createDataLayout());
     _ir->dcomputetarget = this;
   }
diff --git a/gen/dcompute/targetOCL.cpp b/gen/dcompute/targetOCL.cpp
index ae5cf812989..b93850c95e4 100644
--- a/gen/dcompute/targetOCL.cpp
+++ b/gen/dcompute/targetOCL.cpp
@@ -73,14 +73,19 @@ class TargetOCL : public DComputeTarget {
     const bool is64 = global.params.targetTriple->isArch64Bit();
 
     _ir = new IRState("dcomputeTargetOCL", ctx);
-    std::string targTriple = is64 ? SPIR_TARGETTRIPLE64
-                                  : SPIR_TARGETTRIPLE32;
+    std::string targTripleStr = is64 ? SPIR_TARGETTRIPLE64
+                                     : SPIR_TARGETTRIPLE32;
+#if LDC_LLVM_VER >= 2100
+    llvm::Triple targTriple = llvm::Triple(targTripleStr);
+#else
+    std::string targTriple = targTripleStr;
+#endif
     _ir->module.setTargetTriple(targTriple);
 
 #if LDC_LLVM_VER >= 1600
     auto floatABI = ::FloatABI::Hard;
     targetMachine = createTargetMachine(
-            targTriple,
+            targTripleStr,
             is64 ? "spirv64" : "spirv32",
             "", {},
             is64 ? ExplicitBitness::M64 : ExplicitBitness::M32, floatABI,

From adb5dd915233cd28e5f5056d2afeb9a50b2d8bf3 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 13:52:10 +0800
Subject: [PATCH 2/9] [LLVM 21] `Intrinsic::getAttributes` now takes a
 `FunctionType`

---
 gen/tocall.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/gen/tocall.cpp b/gen/tocall.cpp
index d33d3d8c5bc..edc5ef837ce 100644
--- a/gen/tocall.cpp
+++ b/gen/tocall.cpp
@@ -1044,7 +1044,11 @@ DValue *DtoCallFunction(Loc loc, Type *resulttype, DValue *fnval,
     call->setCallingConv(cf->getCallingConv());
     if (cf->isIntrinsic()) { // override intrinsic attrs
       attrlist =
-          llvm::Intrinsic::getAttributes(gIR->context(), cf->getIntrinsicID());
+          llvm::Intrinsic::getAttributes(gIR->context(), cf->getIntrinsicID()
+#if LDC_LLVM_VER >= 2100
+                                         ,cf->getFunctionType()
+#endif
+                                         );
     }
   } else if (dfnval) {
     call->setCallingConv(getCallingConvention(dfnval->func));

From ef11f5f7a57a2fd0cf3ae66842d56337cbaef52f Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 13:53:08 +0800
Subject: [PATCH 3/9] [LLVM 21] update druntime's `ldc/intrinsics.di`

---
 runtime/druntime/src/ldc/intrinsics.di | 1 +
 1 file changed, 1 insertion(+)

diff --git a/runtime/druntime/src/ldc/intrinsics.di b/runtime/druntime/src/ldc/intrinsics.di
index 10b08ca41af..c0d88d8e2d7 100644
--- a/runtime/druntime/src/ldc/intrinsics.di
+++ b/runtime/druntime/src/ldc/intrinsics.di
@@ -26,6 +26,7 @@ else version (LDC_LLVM_1800) enum LLVM_version = 1800;
 else version (LDC_LLVM_1801) enum LLVM_version = 1801;
 else version (LDC_LLVM_1901) enum LLVM_version = 1901;
 else version (LDC_LLVM_2001) enum LLVM_version = 2001;
+else version (LDC_LLVM_2100) enum LLVM_version = 2100;
 else static assert(false, "LDC LLVM version not supported");
 
 enum LLVM_atleast(int major) = (LLVM_version >= major * 100);

From b6ffa391d8c0f9b048e87ac0db5d99eb02d9fec5 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 16:05:07 +0800
Subject: [PATCH 4/9] [LLVM 21] `createTargetMachine` now takes a `Triple`

---
 driver/targetmachine.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/driver/targetmachine.cpp b/driver/targetmachine.cpp
index f429797b5d0..0afc279bcca 100644
--- a/driver/targetmachine.cpp
+++ b/driver/targetmachine.cpp
@@ -652,7 +652,13 @@ createTargetMachine(const std::string targetTriple, const std::string arch,
                     finalFeaturesString.c_str());
   }
 
-  return target->createTargetMachine(triple.str(), cpu, finalFeaturesString,
+  return target->createTargetMachine(
+#if LDC_LLVM_VER >= 2100
+                                     triple,
+#else
+                                     triple.str(),
+#endif
+                                     cpu, finalFeaturesString,
                                      targetOptions, relocModel, codeModel,
                                      static_cast<llvm::CodeGenOptLevel>(codeGenOptLevel));
 }

From 9c68ed435b72856bb862c03a3e9ea24727f3b6d3 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 16:07:36 +0800
Subject: [PATCH 5/9] [LLVM 21]  remove deprecate calls of `llvm::Pointer::get`

---
 gen/abi/aarch64.cpp                  | 2 +-
 gen/classes.cpp                      | 2 +-
 gen/dcompute/druntime.h              | 5 +++--
 gen/nested.cpp                       | 6 +++---
 gen/passes/SimplifyDRuntimeCalls.cpp | 3 ++-
 gen/toir.cpp                         | 2 +-
 gen/variable_lifetime.cpp            | 2 +-
 ir/irtypeclass.cpp                   | 5 ++---
 ir/irtypefunction.cpp                | 6 +++---
 ir/irtypestruct.cpp                  | 2 +-
 10 files changed, 18 insertions(+), 17 deletions(-)

diff --git a/gen/abi/aarch64.cpp b/gen/abi/aarch64.cpp
index f90efa298a8..92931238fa2 100644
--- a/gen/abi/aarch64.cpp
+++ b/gen/abi/aarch64.cpp
@@ -130,7 +130,7 @@ struct AArch64TargetABI : TargetABI {
     // compiler magic: pass va_list args implicitly by reference
     if (!isReturnVal && isAAPCS64VaList(t)) {
       arg.byref = true;
-      arg.ltype = LLPointerType::getUnqual(arg.ltype);
+      arg.ltype = LLPointerType::get(getGlobalContext(), 0);
       return;
     }
 
diff --git a/gen/classes.cpp b/gen/classes.cpp
index 832ef2398fd..4f53670ad8c 100644
--- a/gen/classes.cpp
+++ b/gen/classes.cpp
@@ -483,7 +483,7 @@ DtoVirtualFunctionPointer(DValue *inst, FuncDeclaration *fdecl) {
   // get the vtbl for objects
   vtable = DtoGEP(irtc->getMemoryLLType(), vthis, 0u, 0);
   // load vtbl ptr
-  vtable = DtoLoad(LLPointerType::getUnqual(vtblType), vtable);
+  vtable = DtoLoad(LLPointerType::get(getGlobalContext(), 0), vtable);
   // index vtbl
   const std::string name = fdecl->toChars();
   const auto vtblname = name + "@vtbl";
diff --git a/gen/dcompute/druntime.h b/gen/dcompute/druntime.h
index 1008c3cb399..6ff3b2c8a8b 100644
--- a/gen/dcompute/druntime.h
+++ b/gen/dcompute/druntime.h
@@ -14,6 +14,7 @@
 #include "dmd/aggregate.h"
 #include "dmd/mtype.h"
 #include "gen/dcompute/target.h"
+#include "gen/llvmhelpers.h"
 #include "gen/irstate.h"
 #include "gen/llvm.h"
 #include "gen/tollvm.h"
@@ -37,11 +38,11 @@ struct DcomputePointer {
   Type *type;
   DcomputePointer(int as, Type *ty) : addrspace(as), type(ty) {}
   LLType *toLLVMType(bool translate) {
-    auto llType = DtoType(type);
+    DtoType(type);
     int as = addrspace;
     if (translate)
       as = gIR->dcomputetarget->mapping[as];
-    return LLPointerType::get(llType, as);
+    return LLPointerType::get(getGlobalContext(), as);
   }
 };
 llvm::Optional<DcomputePointer> toDcomputePointer(StructDeclaration *sd);
diff --git a/gen/nested.cpp b/gen/nested.cpp
index ac9e257d849..fcf9086ba05 100644
--- a/gen/nested.cpp
+++ b/gen/nested.cpp
@@ -170,7 +170,7 @@ DValue *DtoNestedVariable(Loc loc, Type *astype, VarDeclaration *vd,
     IF_LOG Logger::cout() << "Frame index: " << *val << '\n';
     currFrame = getIrFunc(fd)->frameType;
     gIR->DBuilder.OpDeref(dwarfAddrOps);
-    val = DtoAlignedLoad(LLPointerType::getUnqual(currFrame), val,
+    val = DtoAlignedLoad(LLPointerType::get(getGlobalContext(), 0), val,
                          (std::string(".frame.") + vdparent->toChars()).c_str());
     IF_LOG Logger::cout() << "Frame: " << *val << '\n';
   }
@@ -417,7 +417,7 @@ static void DtoCreateNestedContextType(FuncDeclaration *fd) {
       builder.addType(innerFrameType->getElementType(i), target.ptrsize);
     }
     // Add frame pointer type for last frame
-    builder.addType(LLPointerType::getUnqual(innerFrameType), target.ptrsize);
+    builder.addType(LLPointerType::get(getGlobalContext(), 0), target.ptrsize);
   }
 
   // Add the direct nested variables of this function, and update their
@@ -505,7 +505,7 @@ void DtoCreateNestedContext(FuncGenState &funcGen) {
         mem = gIR->ir->CreateAdd(mem, DtoConstSize_t(mask));
         mem = gIR->ir->CreateAnd(mem, DtoConstSize_t(~mask));
         frame =
-            gIR->ir->CreateIntToPtr(mem, LLPointerType::getUnqual(frameType), ".frame");
+            gIR->ir->CreateIntToPtr(mem, LLPointerType::get(getGlobalContext(), 0), ".frame");
       }
     } else {
       frame = DtoRawAlloca(frameType, frameAlignment, ".frame");
diff --git a/gen/passes/SimplifyDRuntimeCalls.cpp b/gen/passes/SimplifyDRuntimeCalls.cpp
index 82af7c6dd1e..67bfaea4871 100644
--- a/gen/passes/SimplifyDRuntimeCalls.cpp
+++ b/gen/passes/SimplifyDRuntimeCalls.cpp
@@ -18,6 +18,7 @@
 
 #include "gen/passes/Passes.h"
 #include "gen/passes/SimplifyDRuntimeCalls.h"
+#include "gen/llvmhelpers.h"
 #include "gen/tollvm.h"
 #include "gen/runtime.h"
 #include "llvm/ADT/Statistic.h"
@@ -183,7 +184,7 @@ Value *ArraySliceCopyOpt::CallOptimizer(Function *Callee, CallInst *CI,
                      IRBuilder<> &B) {
   // Verify we have a reasonable prototype for _d_array_slice_copy
   const FunctionType *FT = Callee->getFunctionType();
-  const llvm::Type *VoidPtrTy = PointerType::getUnqual(B.getInt8Ty());
+  const llvm::Type *VoidPtrTy = PointerType::get(getGlobalContext(), 0);
   if (Callee->arg_size() != 5 || FT->getReturnType() != B.getVoidTy() ||
       FT->getParamType(0) != VoidPtrTy ||
       !isa<IntegerType>(FT->getParamType(1)) ||
diff --git a/gen/toir.cpp b/gen/toir.cpp
index e39f2e08fe0..fc8d65a8543 100644
--- a/gen/toir.cpp
+++ b/gen/toir.cpp
@@ -2826,7 +2826,7 @@ class ToElemVisitor : public Visitor {
       LLValue *val = DtoRVal(ex);
 
       // Get and load vtbl pointer.
-      llvm::Value *vtbl = DtoLoad(LLPointerType::getUnqual(vtblType),
+      llvm::Value *vtbl = DtoLoad(LLPointerType::get(getGlobalContext(), 0),
                                   DtoGEP(irtc->getMemoryLLType(), val, 0u, 0));
 
       // TypeInfo ptr is first vtbl entry.
diff --git a/gen/variable_lifetime.cpp b/gen/variable_lifetime.cpp
index e479238fa45..1f2db0e3ce4 100644
--- a/gen/variable_lifetime.cpp
+++ b/gen/variable_lifetime.cpp
@@ -31,7 +31,7 @@ static llvm::cl::opt<bool> fEmitLocalVarLifetime(
 LocalVariableLifetimeAnnotator::LocalVariableLifetimeAnnotator(IRState &irs)
     : irs(irs) {
   allocaType =
-      LLPointerType::get(LLType::getInt8Ty(irs.context()),
+      LLPointerType::get(irs.context(),
                          irs.module.getDataLayout().getAllocaAddrSpace());
 }
 
diff --git a/ir/irtypeclass.cpp b/ir/irtypeclass.cpp
index 85cd79d1d07..696e2a8b40e 100644
--- a/ir/irtypeclass.cpp
+++ b/ir/irtypeclass.cpp
@@ -49,8 +49,7 @@ void IrTypeClass::addClassData(AggrTypeBuilder &builder,
 
       // add to the interface map
       addInterfaceToMap(b->sym, builder.currentFieldIndex());
-      auto vtblTy = LLArrayType::get(getOpaquePtrType(), b->sym->vtbl.length);
-      builder.addType(llvm::PointerType::get(vtblTy, 0), target.ptrsize);
+      builder.addType(llvm::PointerType::get(getGlobalContext(), 0), target.ptrsize);
 
       ++num_interface_vtbls;
     }
@@ -92,7 +91,7 @@ llvm::Type *IrTypeClass::getMemoryLLType() {
   }
 
   // add vtbl
-  builder.addType(llvm::PointerType::get(vtbl_type, 0), target.ptrsize);
+  builder.addType(llvm::PointerType::get(getGlobalContext(), 0), target.ptrsize);
 
   if (cd->isInterfaceDeclaration()) {
     // interfaces are just a vtable
diff --git a/ir/irtypefunction.cpp b/ir/irtypefunction.cpp
index 85eaed2e4fd..345a894be2f 100644
--- a/ir/irtypefunction.cpp
+++ b/ir/irtypefunction.cpp
@@ -10,6 +10,7 @@
 #include "ir/irtypefunction.h"
 
 #include "dmd/mtype.h"
+#include "gen/llvmhelpers.h"
 #include "gen/functions.h"
 #include "gen/irstate.h"
 #include "gen/tollvm.h"
@@ -53,9 +54,8 @@ IrTypeDelegate *IrTypeDelegate::get(Type *t) {
   assert(!ctype);
 
   IrFuncTy irFty(tf);
-  llvm::Type *ltf =
-      DtoFunctionType(tf, irFty, nullptr, pointerTo(Type::tvoid));
-  llvm::Type *fptr = LLPointerType::get(ltf, gDataLayout->getProgramAddressSpace());
+  DtoFunctionType(tf, irFty, nullptr, pointerTo(Type::tvoid));
+  llvm::Type *fptr = LLPointerType::get(getGlobalContext(), gDataLayout->getProgramAddressSpace());
   llvm::Type *types[] = {getOpaquePtrType(), fptr};
   LLStructType *lt = LLStructType::get(gIR->context(), types, false);
 
diff --git a/ir/irtypestruct.cpp b/ir/irtypestruct.cpp
index 4ce3041224a..cac45683e0a 100644
--- a/ir/irtypestruct.cpp
+++ b/ir/irtypestruct.cpp
@@ -80,7 +80,7 @@ IrTypeStruct *IrTypeStruct::get(StructDeclaration *sd) {
     int realAS = gIR->dcomputetarget->mapping[p->addrspace];
 
     llvm::SmallVector<LLType *, 1> body;
-    body.push_back(LLPointerType::get(DtoMemType(p->type), realAS));
+    body.push_back(LLPointerType::get(getGlobalContext(), realAS));
 
     isaStruct(t->type)->setBody(body, false);
     VarGEPIndices v;

From 9809817ee4ed3960ae6d168c632043c63916b977 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 16:37:31 +0800
Subject: [PATCH 6/9] [LLVM 21]  `llvm::LocationSize` for AliasAnalysis

---
 gen/passes/SimplifyDRuntimeCalls.cpp | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/gen/passes/SimplifyDRuntimeCalls.cpp b/gen/passes/SimplifyDRuntimeCalls.cpp
index 67bfaea4871..ebbe2e166f0 100644
--- a/gen/passes/SimplifyDRuntimeCalls.cpp
+++ b/gen/passes/SimplifyDRuntimeCalls.cpp
@@ -209,8 +209,16 @@ Value *ArraySliceCopyOpt::CallOptimizer(Function *Callee, CallInst *CI,
     Sz = (Int->getValue() * ElemSz->getValue()).getZExtValue();
   }
 
+#if LDC_LLVM_VER >= 2100
+  llvm::LocationSize Sz2 =
+      (Sz == llvm::MemoryLocation::UnknownSize)
+          ? llvm::LocationSize::beforeOrAfterPointer()
+          : llvm::LocationSize::precise(Sz);
+#else
+  std::uint64_t Sz2 = Sz;
+#endif
   // Check if the pointers may alias
-  if (AA->alias(CI->getOperand(0), Sz, CI->getOperand(2), Sz)) {
+  if (AA->alias(CI->getOperand(0), Sz2, CI->getOperand(2), Sz2)) {
     return nullptr;
   }
 

From 47cb15bcf53b417929ce971b300c1f9d21d1cb43 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 16:10:47 +0800
Subject: [PATCH 7/9] [LLVM 21] Use `Intrinsic::getOrInsertDeclaration`

---
 gen/variable_lifetime.cpp | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/gen/variable_lifetime.cpp b/gen/variable_lifetime.cpp
index 1f2db0e3ce4..cf21104de2f 100644
--- a/gen/variable_lifetime.cpp
+++ b/gen/variable_lifetime.cpp
@@ -78,7 +78,12 @@ llvm::Function *LocalVariableLifetimeAnnotator::getLLVMLifetimeStartFn() {
   if (lifetimeStartFunction)
     return lifetimeStartFunction;
 
-  lifetimeStartFunction = llvm::Intrinsic::getDeclaration(
+  lifetimeStartFunction = llvm::Intrinsic::
+#if LDC_LLVM_VER >= 2100
+    getOrInsertDeclaration(
+#else
+    getDeclaration(
+#endif
       &irs.module, llvm::Intrinsic::lifetime_start, allocaType);
   assert(lifetimeStartFunction);
   return lifetimeStartFunction;
@@ -89,7 +94,12 @@ llvm::Function *LocalVariableLifetimeAnnotator::getLLVMLifetimeEndFn() {
   if (lifetimeEndFunction)
     return lifetimeEndFunction;
 
-  lifetimeEndFunction = llvm::Intrinsic::getDeclaration(
+  lifetimeEndFunction = llvm::Intrinsic::
+#if LDC_LLVM_VER >= 2100
+    getOrInsertDeclaration(
+#else
+    getDeclaration(
+#endif
       &irs.module, llvm::Intrinsic::lifetime_end, allocaType);
   assert(lifetimeEndFunction);
   return lifetimeEndFunction;

From 3601a412af23ab3865e9b19aaa73ca675e03e264 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 16:13:51 +0800
Subject: [PATCH 8/9] [LLVM 21] `llvm::Attribute::NoCapture` removed

---
 gen/abi/generic.h                   |   4 ++
 gen/passes/GarbageCollect2Stack.cpp |   9 +++
 gen/runtime.cpp                     | 101 ++++++++++++++++++----------
 3 files changed, 79 insertions(+), 35 deletions(-)

diff --git a/gen/abi/generic.h b/gen/abi/generic.h
index 6f772e434c3..6458d28b8bc 100644
--- a/gen/abi/generic.h
+++ b/gen/abi/generic.h
@@ -260,7 +260,11 @@ struct IndirectByvalRewrite : ABIRewrite {
     auto &attrs = arg.attrs;
     attrs.clear();
     attrs.addAttribute(LLAttribute::NoAlias);
+#if LDC_LLVM_VER >= 2100
+    attrs.addCapturesAttr(llvm::CaptureInfo::none());
+#else
     attrs.addAttribute(LLAttribute::NoCapture);
+#endif
     if (auto alignment = DtoAlignment(arg.type))
       attrs.addAlignmentAttr(alignment);
   }
diff --git a/gen/passes/GarbageCollect2Stack.cpp b/gen/passes/GarbageCollect2Stack.cpp
index 8910d2d9840..bedfa937c02 100644
--- a/gen/passes/GarbageCollect2Stack.cpp
+++ b/gen/passes/GarbageCollect2Stack.cpp
@@ -726,10 +726,19 @@ bool isSafeToStackAllocate(BasicBlock::iterator Alloc, Value *V,
       auto B = CB->arg_begin(), E = CB->arg_end();
       for (auto A = B; A != E; ++A) {
         if (A->get() == V) {
+#if LDC_LLVM_VER >= 2100
+          if (CB->paramHasAttr(A - B, llvm::Attribute::AttrKind::Captures)) {
+            return capturesNothing(
+                        CB->getParamAttr(A - B, llvm::Attribute::AttrKind::Captures)
+                           .getCaptureInfo());
+          }
+
+#else
           if (!CB->paramHasAttr(A - B, llvm::Attribute::AttrKind::NoCapture)) {
             // The parameter is not marked 'nocapture' - captured.
             return false;
           }
+#endif
 
           if (auto call = dyn_cast<CallInst>(static_cast<Instruction *>(CB))) {
             if (call->isTailCall()) {
diff --git a/gen/runtime.cpp b/gen/runtime.cpp
index 036b8af5829..cde90036f7a 100644
--- a/gen/runtime.cpp
+++ b/gen/runtime.cpp
@@ -498,44 +498,75 @@ static void buildRuntimeModule() {
   //////////////////////////////////////////////////////////////////////////////
 
   // Construct some attribute lists used below (possibly multiple times)
-  AttrSet NoAttrs,
-      Attr_NoUnwind(NoAttrs, LLAttributeList::FunctionIndex,
-                    llvm::Attribute::NoUnwind),
+  AttrSet NoAttrs, Attr_NoUnwind, Attr_ReadOnly, Attr_ReadOnly_NoUnwind, Attr_Cold, Attr_Cold_NoReturn, Attr_Cold_NoReturn_NoUnwind,
+          Attr_ReadOnly_1_NoCapture, Attr_ReadOnly_1_3_NoCapture, Attr_ReadOnly_NoUnwind_1_NoCapture,
+          Attr_ReadOnly_NoUnwind_1_2_NoCapture, Attr_1_NoCapture, Attr_1_2_NoCapture, Attr_1_3_NoCapture,
+          Attr_1_4_NoCapture;
+  // `nounwind`
+  {
+    auto addNoUnwind = [&](AttrSet& a) {
+      llvm::AttrBuilder ab(context);
+      ab.addAttribute(llvm::Attribute::NoUnwind);
+      a.addToFunction(ab);
+    };
+    addNoUnwind(Attr_NoUnwind);
+    addNoUnwind(Attr_Cold_NoReturn_NoUnwind);
+    addNoUnwind(Attr_ReadOnly_NoUnwind);
+    addNoUnwind(Attr_ReadOnly_NoUnwind_1_NoCapture);
+    addNoUnwind(Attr_ReadOnly_NoUnwind_1_2_NoCapture);
+  }
+  // `readonly`
+  {
+    auto addReadOnly = [&](AttrSet& a) {
 #if LDC_LLVM_VER >= 1600
-      Attr_ReadOnly(llvm::AttributeList().addFnAttribute(
-          context, llvm::Attribute::getWithMemoryEffects(
-                       context, llvm::MemoryEffects::readOnly()))),
+      a = a.merge(AttrSet(llvm::AttributeList().addFnAttribute(
+                          context, llvm::Attribute::getWithMemoryEffects(
+                            context, llvm::MemoryEffects::readOnly()))));
+#else
+      llvm::AttrBuilder ab(context);
+      ab.addAttribute(llvm::Attribute::ReadOnly);
+      a = a.addToFunction(ab);
+#endif
+    };
+    addReadOnly(Attr_ReadOnly);
+    addReadOnly(Attr_ReadOnly_NoUnwind);
+    addReadOnly(Attr_ReadOnly_1_NoCapture);
+    addReadOnly(Attr_ReadOnly_1_3_NoCapture);
+    addReadOnly(Attr_ReadOnly_NoUnwind_1_NoCapture);
+    addReadOnly(Attr_ReadOnly_NoUnwind_1_2_NoCapture);
+  }
+  // `cold`
+  {
+    auto addCold = [&](AttrSet& a) {
+      llvm::AttrBuilder ab(context);
+      ab.addAttribute(llvm::Attribute::Cold);
+    };
+    addCold(Attr_Cold);
+    addCold(Attr_Cold_NoReturn);
+    addCold(Attr_Cold_NoReturn_NoUnwind);
+  }
+  // `nocapture`/ `captures(none)`
+  {
+    auto addCapturesNone = [&](int extra, AttrSet& a) {
+      llvm::AttrBuilder ab(context);
+#if LDC_LLVM_VER >= 2100
+      ab.addCapturesAttr(llvm::CaptureInfo::none());
 #else
-      Attr_ReadOnly(NoAttrs, LLAttributeList::FunctionIndex,
-                    llvm::Attribute::ReadOnly),
+      ab.addAttribute(llvm::Attribute::NoCapture);
 #endif
-      Attr_Cold(NoAttrs, LLAttributeList::FunctionIndex, llvm::Attribute::Cold),
-      Attr_Cold_NoReturn(Attr_Cold, LLAttributeList::FunctionIndex,
-                         llvm::Attribute::NoReturn),
-      Attr_Cold_NoReturn_NoUnwind(Attr_Cold_NoReturn,
-                                  LLAttributeList::FunctionIndex,
-                                  llvm::Attribute::NoUnwind),
-      Attr_ReadOnly_NoUnwind(Attr_ReadOnly, LLAttributeList::FunctionIndex,
-                             llvm::Attribute::NoUnwind),
-      Attr_ReadOnly_1_NoCapture(Attr_ReadOnly, LLAttributeList::FirstArgIndex,
-                                llvm::Attribute::NoCapture),
-      Attr_ReadOnly_1_3_NoCapture(Attr_ReadOnly_1_NoCapture,
-                                  LLAttributeList::FirstArgIndex + 2,
-                                  llvm::Attribute::NoCapture),
-      Attr_ReadOnly_NoUnwind_1_NoCapture(Attr_ReadOnly_1_NoCapture,
-                                         LLAttributeList::FunctionIndex,
-                                         llvm::Attribute::NoUnwind),
-      Attr_ReadOnly_NoUnwind_1_2_NoCapture(Attr_ReadOnly_NoUnwind_1_NoCapture,
-                                           LLAttributeList::FirstArgIndex + 1,
-                                           llvm::Attribute::NoCapture),
-      Attr_1_NoCapture(NoAttrs, LLAttributeList::FirstArgIndex,
-                       llvm::Attribute::NoCapture),
-      Attr_1_2_NoCapture(Attr_1_NoCapture, LLAttributeList::FirstArgIndex + 1,
-                         llvm::Attribute::NoCapture),
-      Attr_1_3_NoCapture(Attr_1_NoCapture, LLAttributeList::FirstArgIndex + 2,
-                         llvm::Attribute::NoCapture),
-      Attr_1_4_NoCapture(Attr_1_NoCapture, LLAttributeList::FirstArgIndex + 3,
-                         llvm::Attribute::NoCapture);
+      a.addToParam(0, ab);
+      if (extra)
+        a.addToParam(extra-1, ab);
+    };
+    addCapturesNone(0, Attr_ReadOnly_1_NoCapture);
+    addCapturesNone(3, Attr_ReadOnly_1_3_NoCapture);
+    addCapturesNone(0, Attr_ReadOnly_NoUnwind_1_NoCapture);
+    addCapturesNone(2, Attr_ReadOnly_NoUnwind_1_2_NoCapture);
+    addCapturesNone(0, Attr_1_NoCapture);
+    addCapturesNone(2, Attr_1_2_NoCapture);
+    addCapturesNone(3, Attr_1_3_NoCapture);
+    addCapturesNone(4, Attr_1_4_NoCapture);
+  }
 
   //////////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////////

From 0eaddc70076b8822acf24af18d0f24c4946e9d06 Mon Sep 17 00:00:00 2001
From: Nicholas Wilson <iamthewilsonator@hotmail.com>
Date: Sun, 8 Jun 2025 18:09:16 +0800
Subject: [PATCH 9/9] [LLVM 21] GC2Stack: remove  removed `removeCallEdgeFor`

---
 gen/passes/GarbageCollect2Stack.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/gen/passes/GarbageCollect2Stack.cpp b/gen/passes/GarbageCollect2Stack.cpp
index bedfa937c02..631e9f100a6 100644
--- a/gen/passes/GarbageCollect2Stack.cpp
+++ b/gen/passes/GarbageCollect2Stack.cpp
@@ -24,6 +24,9 @@
 #include "llvm/ADT/Statistic.h"
 #include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/StringSwitch.h"
+#if LDC_LLVM_VER >= 2100
+#include "llvm/IR/AbstractCallSite.h"
+#endif
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DataLayout.h"
 #include "llvm/IR/Dominators.h"
@@ -350,7 +353,23 @@ static void RemoveCall(CallBase *CB, const G2StackAnalysis &A) {
 
   // Remove the runtime call.
   if (A.CGNode) {
+#if LDC_LLVM_VER >= 2100
+    //FIXME: Look into using `LazyCallGraph` and the new pass manager
+    for (auto I = A.CGNode->begin(); ; I++) {
+      assert(I != A.CGNode->end() && "Cannot find callsite to remove!");
+      if (I->first && *I->first == CB) {
+        A.CGNode->removeCallEdge(I);
+
+        // Remove all references to callback functions if there are any.
+        forEachCallbackFunction(*CB, [=](Function *_CB) {
+          A.CGNode->removeOneAbstractEdgeTo(A.CG->getOrInsertFunction(_CB));
+        });
+        break;
+      }
+    }
+#else
     A.CGNode->removeCallEdgeFor(*CB);
+#endif
   }
   static_cast<Instruction *>(CB)->eraseFromParent();
 }
